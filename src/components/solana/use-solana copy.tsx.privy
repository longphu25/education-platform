import { usePrivy } from '@privy-io/react-auth'
import { useMemo, useCallback, useEffect, useState } from 'react'

export type WalletType = 'embedded' | 'external' | null
export type LoginMethod = 'email' | 'phone' | 'social' | 'wallet' | null

/**
 * Custom hook for comprehensive Privy + Solana integration
 * Handles both embedded wallet creation and external wallet connections
 */
export function useSolana() {
  const { ready, authenticated, user, login, logout } = usePrivy()
  const [walletType, setWalletType] = useState<WalletType>(null)
  const [isCreatingWallet, setIsCreatingWallet] = useState(false)
  const [currentCluster, setCurrentCluster] = useState<'devnet' | 'testnet' | 'mainnet-beta'>(() => {
    return (process.env.NEXT_PUBLIC_SOLANA_NETWORK as 'devnet' | 'testnet' | 'mainnet-beta') || 'devnet'
  })
  
  // Determine login method based on user's linked accounts
  const loginMethod = useMemo((): LoginMethod => {
    if (!user?.linkedAccounts) return null
    
    const hasWallet = user.linkedAccounts.some(account => account.type === 'wallet')
    if (hasWallet) return 'wallet'
    
    const hasEmail = user.linkedAccounts.some(account => account.type === 'email')
    if (hasEmail) return 'email'
    
    const hasPhone = user.linkedAccounts.some(account => account.type === 'phone')
    if (hasPhone) return 'phone'
    
    const hasSocial = user.linkedAccounts.some(account => 
      account.type.includes('oauth') || ['google_oauth', 'twitter_oauth', 'discord_oauth'].includes(account.type)
    )
    if (hasSocial) return 'social'
    
    return null
  }, [user?.linkedAccounts])

  // Determine wallet type and create embedded wallet if needed
  useEffect(() => {
    if (!authenticated || !user || !loginMethod) {
      setWalletType(null)
      return
    }

    if (loginMethod === 'wallet') {
      // User logged in with external wallet
      setWalletType('external')
    } else {
      // User logged in with email/phone/social - needs embedded wallet
      setWalletType('embedded')
      
      // Auto-create embedded wallet for non-wallet users
      // This would be replaced with actual Privy embedded wallet creation
      if (!isCreatingWallet) {
        setIsCreatingWallet(true)
        console.log(`ðŸ”¨ Creating embedded Solana wallet for ${loginMethod} user...`)
        
        // Simulate wallet creation delay
        setTimeout(() => {
          console.log('âœ… Embedded Solana wallet created!')
          setIsCreatingWallet(false)
        }, 2000)
      }
    }
  }, [authenticated, user, loginMethod, isCreatingWallet])

  // Get wallet from user's linked accounts
  const externalWallet = useMemo(() => {
    if (!user?.linkedAccounts || walletType !== 'external') return null
    
    const walletAccount = user.linkedAccounts.find(account => 
      account.type === 'wallet' && 'chainType' in account && account.chainType === 'solana'
    )
    
    return walletAccount && 'address' in walletAccount ? {
      address: walletAccount.address,
      type: 'external' as const,
      label: 'Connected Solana Wallet'
    } : null
  }, [user?.linkedAccounts, walletType])

  // Create embedded wallet representation
  const embeddedWallet = useMemo(() => {
    if (!user || walletType !== 'embedded' || isCreatingWallet) return null
    
    return {
      address: `embed_${user.id?.slice(-8)}${Math.random().toString(36).slice(2, 8)}`, // Simulated address
      type: 'embedded' as const,
      label: 'Privy Embedded Wallet'
    }
  }, [user, walletType, isCreatingWallet])

  // Get current active wallet
  const currentWallet = walletType === 'external' ? externalWallet : embeddedWallet

  // Create compatibility account object
  const account = useMemo(() => {
    if (!currentWallet) return null
    
    // Create a proper wallet handle symbol
    const walletHandle = Symbol('uiWalletHandle')
    
    return {
      address: currentWallet.address,
      publicKey: currentWallet.address,
      label: currentWallet.label,
      walletType: currentWallet.type,
      
      // Required UiWalletHandle properties
      [walletHandle]: true,
      '~uiWalletHandle': walletHandle,
      features: {
        signMessage: true,
        signTransaction: true,
        signAndSendTransaction: true,
      },
      
      // Wallet methods (differentiated by type)
      connect: async () => {
        console.log(`Connecting ${currentWallet.type} wallet...`)
      },
      disconnect: async () => {
        console.log(`Disconnecting ${currentWallet.type} wallet...`)
        if (currentWallet.type === 'external') {
          // For external wallets, we might want to just logout
          await logout()
        }
      },
      signMessage: async (message: Uint8Array) => {
        console.log(`Signing message with ${currentWallet.type} wallet:`, message)
        // Would use different signing methods based on wallet type
        return new Uint8Array([1, 2, 3]) // Placeholder
      },
      signTransaction: async (transaction: unknown) => {
        console.log(`Signing transaction with ${currentWallet.type} wallet:`, transaction)
        return transaction // Placeholder
      },
      signAndSendTransaction: async (transaction: unknown) => {
        console.log(`Signing and sending transaction with ${currentWallet.type} wallet:`, transaction)
        return { signature: 'placeholder_signature' }
      },
    } as {
      address: string
      publicKey: string
      label: string
      walletType: 'embedded' | 'external'
      [key: symbol]: unknown
      features: Record<string, boolean>
      connect: () => Promise<void>
      disconnect: () => Promise<void>
      signMessage: (message: Uint8Array) => Promise<Uint8Array>
      signTransaction: (transaction: unknown) => Promise<unknown>
      signAndSendTransaction: (transaction: unknown) => Promise<{ signature: string }>
    }
  }, [currentWallet, logout])

  // Create embedded wallet manually (for users who want additional wallets)
  const createEmbeddedWallet = useCallback(async () => {
    if (!authenticated) {
      throw new Error('User must be authenticated to create embedded wallet')
    }
    
    setIsCreatingWallet(true)
    try {
      console.log('ðŸ”¨ Creating additional embedded wallet...')
      // Would call actual Privy createWallet method here
      await new Promise(resolve => setTimeout(resolve, 2000)) // Simulate creation
      console.log('âœ… Additional embedded wallet created!')
      return { address: `new_embed_${Date.now()}`, type: 'embedded' }
    } catch (error) {
      console.error('Failed to create embedded wallet:', error)
      throw error
    } finally {
      setIsCreatingWallet(false)
    }
  }, [authenticated])

  // Simple Solana client for cluster connectivity checks
  const client = useMemo(() => {
    const endpoint = `https://api.${currentCluster === 'mainnet-beta' ? 'mainnet-beta' : currentCluster}.solana.com`
    
    return {
      rpc: {
        getAccountInfo: () => Promise.resolve(null),
        getVersion: () => ({
          send: async () => {
            try {
              const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  jsonrpc: '2.0',
                  id: 1,
                  method: 'getVersion',
                }),
              })
              const data = await response.json()
              return data.result || { 'solana-core': '1.18.0', 'feature-set': 0 }
            } catch (error) {
              console.error('Failed to get cluster version:', error)
              throw new Error(`Unable to connect to ${currentCluster} cluster`)
            }
          }
        })
      },
      endpoint
    }
  }, [currentCluster])

  // Cluster management
  const setCluster = useCallback((cluster: 'devnet' | 'testnet' | 'mainnet-beta') => {
    setCurrentCluster(cluster)
  }, [])

  // Cluster info object for compatibility with UI components
  const clusterInfo = useMemo(() => {
    const clusterLabels = {
      'devnet': 'Devnet',
      'testnet': 'Testnet', 
      'mainnet-beta': 'Mainnet Beta'
    }
    
    return {
      name: currentCluster,
      network: currentCluster,
      id: currentCluster,
      label: clusterLabels[currentCluster] || currentCluster,
      endpoint: `https://api.${currentCluster === 'mainnet-beta' ? 'mainnet-beta' : currentCluster}.solana.com`
    }
  }, [currentCluster])

  return {
    // Authentication state
    ready,
    authenticated,
    user,
    
    // Wallet state
    account,
    walletType,
    loginMethod,
    isCreatingWallet,
    
    // Wallet objects
    externalWallet,
    embeddedWallet,
    currentWallet,
    
    // Actions
    login,
    logout,
    createEmbeddedWallet,
    
    // Cluster management  
    cluster: clusterInfo, // Return the full cluster object with label
    clusterInfo,
    setCluster,
    
    // Solana client (placeholder)
    client,
  }
}
